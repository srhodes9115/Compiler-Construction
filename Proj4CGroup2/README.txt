The token.y file is the bison file that reserves token names and creates the structure of the program. This document holds the context free grammar rules for the sequencing of the program. In this project, we modified this file to correctly enter variables and functions into the symbol table. We made calls to the symtab functions found in symtab.c to correctly input the values from the code into the symbol table. When token.y is invoked, it creates token.tab.h as a header file which assigns values to the declared tokens. In addition, the file token.tab.c is also created from the bison command. We utilized the error verbose and the expect one bison declarations. We did not utilize the debug feature because it was not necessary for our program to work correctly. 

lex.yy.c is a file that is generated by flex. An output file is generated for this called lex.yy.o

The token.l file outlines the rules for assigning tokens to input strings. It contains the regular expression descriptions and their associated actions. In our case, it also advances the line numbers and character numbers as strings are scanned. When a number is encounted, the string is converted to its integer equivalent using the c function atoi().  

The parseMain.c file contains the program that invokes the parser. It is made up of a conditional statement in which the function yyparse() is called. If the program is parsed correctly (yyparse returns 0), the program prints Parse Successful. If there is a parsing error (yyparse returns 1) due to an invalid sequence, invalid token, or an invalid character, the program prints an error message with the line and character number of the error which were computed in the scanner. parseMain.o is an output file that is automatically generated. 

The symbtab.h file holds the function declarations for each function in symtab.c.

Contained in symbtab.c are the functions associated with the generation and utilization of the symbol table. Each symbol table entry is a structure that holds its variable name, JVM num, scope, param, kind, type, array size and invalid status. If the entry does not have one of the fields, it is left blank in the printed symbol table. The function st_insert correctly places declared variables and functions into the symbol table. If the variable is already declared within the same scope, it prints an error message indicating the error. st_lookup checks to see if a variable is in the symbol table and returns 1 if found and -1 if not found. st_lookupKind is used to detect semantic errors; particularly when variables are used incorrectly according to their kind. (Ex. int x; x[5] = 5; generates this semantic error message) st_lookupType is a function that ensures theres no interchanging between int and void declared variables. Printsymtab simply prints out the resulting symbol table when the program has finished running. 

We included a Makefile for our parser. It allows the user to simply type make parse and all relevant files will be updated and compiled. This command generates an output file called parse. To test the parser on input files, simply type into the terminal: ./parse <inputfile.c>outputfilename. All commands necessary are contained in the Makefile.
 
The TestResults subfolder contains all of the input and output files to test our parser. The symbol table is printed to the file called output. Error messages are printed in the terminal. We created three of our own test cases, contained in the files   testfile1.c, testfile2.c, testfile3.c. Finally, there is a large document titled, TestReport.txt, which  contains every output file in addition to the purpose and outcome of each test case. 

SCANNER
We also chose to implement scanf, as it was not that much more difficult than implementing printf. Once again, scanf only recognizes "%d" and & as valid arguments. This makes sense because integers are the only data type allowed in c-, so there is no reason to allow any other data types. Other than these questions, there are no known bugs in our scanner. Line numbers start at 0, and so do character numbers. Character numbers are incremented every new token and in the event of whitespace. In the case of a comment, every letter, space, etc. is counted; except the starting and ending enclosures (/* */). The specifications said that the character count did not have to be very precise, and we took advantage of this. An additional change we made was that the character mentioned in num_char when an error is presented is num_char-1. When a token is recognized as an error, it advances the number of characters one slot (to count the error character). This makes it confusing to see where errors actually occur, so in our scanMain.c file, when an error is received it prints out the num_chars -1, so that the spot where the error is located one space before the error. 

PARSER
Our context free grammar supports scanf. Our parser returns either "parse successful," or "parse error," like a true parser. If there is an error in the entered code, it returns the error message and the line and token number of the error. The function yyerror indicates the token in which the error occurred.  An additional change we made was that the character mentioned in num_char when an error is presented is num_char-1. When a token is recognized as an error, it advances the number of characters one slot (to count the error character). This makes it confusing to see where errors actually occur, so in our parseMain.c file, when an error is received it prints out the num_chars -1, so that the spot where the error is located one space before the error. We also modified the scanner a little bit in project 2. Originally, in the case of a comment, the lexical analyzer just returned. It did not return a token, it just returned. We did not realize this was a problem until we attempted to parse. We changed the return statement to a break statement and this successfully solved our problems. No additional changes were made to the scanner. There are no known bugs or problems in our parser.

SEMANTIC ANALYZER
According to the test file results, our semantic analyzer seems to be working as expected. One warning was generated in compiling our program. We used a function in token.y called concat, which allows an error message to print with the id name that caused the error. This function was discovered through the Villanova Computer Science department resources, and the warning does not prevent our semantic analyzer from running correctly. A global variable, globalFunction, is used to identify variables declared in the same scope but in different functions. If two variables with the same name are declared in two separate functions, a semantic error should not be generated. This global variable helps detect this occurence. If there is no main function in the source program, an error message is printed and the symbol table is not printed out. If main is included in the source program but is not the last function, an error message is printed and the symbol table is also printed. The changes made in this portion of the project are mostly found in the token.y and symtab.c files. The context free grammar was altered to recognize semantic errors and to correctly enter program components into a symbol table using the functions in symtab.c. If there is a semantic error in the code, the program returns a descriptive error message indicating the line and column number of the error. The printed symbol table reveals the name, JVM_num, scope, params, kind, type, array size of each ID. The type column separates the functions from the arrays and the general variables. An entry of 261 means that entry is a void function, 259 indicates the variable is of type integer. The array size column holds the size of the array entries. If an entry is a function or a variable, that field is left blank. If an array size is not specified, (i.e. int a[]), the value is hardcoded to 0. Notice that if a given variable is no longer valid, there is an x marked in the invalid column. This indicates that the variable is no longer considered part of the current scope. 

CODE GENERATOR
All error messages are printed to the output file, do not look for them in the terminal. If a file is tested with a syntax or semantic error, the error message shows up in the output file only. This is imperative to determining if our compiler is working correctly. We're still having one small issue with the fact.c testfile. In this testfile, there is a global variable and a function parameter that are the same (int x). When x is called in main, it references the x from the function (which should be invalid) and NOT the global x (which it should be accessing). We fooled around with this error for some time, but ultimately could not fix it. Over the course of this project, we added many functions to gencode.c to help us generate the jvm code. Also, we were having issues with printing the parameter types for functions. We tried several different methods, but none worked. For now, our code generator just prints out as many 'I's as there are parameters.

gencode.c is the file that holds the functions used to generate the Java Virtual Machine Code. Most of the code generation is done using printf statements. Integer and Void have different representations in JVM code, so gencode.c was also used to check for return types and handle them accordingly. For Miniproject 4, we were given a Gencode.c file that had some functions in there already. We built on this existing code for this project. We copied the text from genLabel.c and put it inside gencode.c as a function.

gencode.h is the header file that contains all the function declarations in Gencode.c.

The gencodeMain.c file contains the program that invokes the code generator. The file invokes the parser, and returns and error if the input code cannot be parsed. This file was given to us in miniproject4 and we did not make any changes to it. gencodeMain.o is an output file that is automatically generated.

The regular just output file holds the current symbol table.

output.txt is the file we've been using to write the JVM generated code to. If there is an error in the program (semantic or syntax), the error message will be written to this file. Otherwise, on a successful translation by our compiler, the complete generated code is written to this file in full.

The TestResults subfolder contains all of the input and output files to test our compiler. Every provided input file is named exactly the same way it was given to us;
(bsort.c, err0.c, etc). We created three of our own test cases, contained in the files testfile1.txt, testfile2.txt, testfile3.txt. Finally, there is a large document titled, TestReport.txt, which  contains every JVM code output generated by our files in addition to the purpose and outcome of each test case. 
